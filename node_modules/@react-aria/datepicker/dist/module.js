import {createFocusManager as $cIPI0$createFocusManager, getFocusableTreeWalker as $cIPI0$getFocusableTreeWalker} from "@react-aria/focus";
import {useId as $cIPI0$useId, useDescription as $cIPI0$useDescription, filterDOMProps as $cIPI0$filterDOMProps, mergeProps as $cIPI0$mergeProps, isMac as $cIPI0$isMac, scrollIntoView as $cIPI0$scrollIntoView, getScrollParent as $cIPI0$getScrollParent, useEvent as $cIPI0$useEvent, useLayoutEffect as $cIPI0$useLayoutEffect, isIOS as $cIPI0$isIOS, useLabels as $cIPI0$useLabels} from "@react-aria/utils";
import $cIPI0$react, {useMemo as $cIPI0$useMemo, useRef as $cIPI0$useRef, useEffect as $cIPI0$useEffect} from "react";
import {useField as $cIPI0$useField} from "@react-aria/label";
import {useMessageFormatter as $cIPI0$useMessageFormatter, useLocale as $cIPI0$useLocale, useDateFormatter as $cIPI0$useDateFormatter, useFilter as $cIPI0$useFilter} from "@react-aria/i18n";
import {useFocusWithin as $cIPI0$useFocusWithin, usePress as $cIPI0$usePress} from "@react-aria/interactions";
import {toCalendar as $cIPI0$toCalendar, CalendarDate as $cIPI0$CalendarDate} from "@internationalized/date";
import {NumberParser as $cIPI0$NumberParser} from "@internationalized/number";
import {useSpinButton as $cIPI0$useSpinButton} from "@react-aria/spinbutton";
import {MessageDictionary as $cIPI0$MessageDictionary} from "@internationalized/message";

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}



var $204383cf4f6b0d06$exports = {};
var $f23889fffbde9058$exports = {};
$f23889fffbde9058$exports = JSON.parse("{\"calendar\":\"التقويم\",\"day\":\"يوم\",\"dayPeriod\":\"ص/م\",\"endDate\":\"تاريخ الانتهاء\",\"era\":\"العصر\",\"hour\":\"الساعات\",\"minute\":\"الدقائق\",\"month\":\"الشهر\",\"second\":\"الثواني\",\"selectedDateDescription\":\"تاريخ محدد: {date}\",\"selectedRangeDescription\":\"المدى الزمني المحدد: {startDate} إلى {endDate}\",\"selectedTimeDescription\":\"الوقت المحدد: {time}\",\"startDate\":\"تاريخ البدء\",\"timeZoneName\":\"التوقيت\",\"weekday\":\"اليوم\",\"year\":\"السنة\"}");


var $09d9badaa8903929$exports = {};
$09d9badaa8903929$exports = JSON.parse("{\"calendar\":\"Календар\",\"day\":\"ден\",\"dayPeriod\":\"пр.об./сл.об.\",\"endDate\":\"Крайна дата\",\"era\":\"ера\",\"hour\":\"час\",\"minute\":\"минута\",\"month\":\"месец\",\"second\":\"секунда\",\"selectedDateDescription\":\"Избрана дата: {date}\",\"selectedRangeDescription\":\"Избран диапазон: {startDate} до {endDate}\",\"selectedTimeDescription\":\"Избрано време: {time}\",\"startDate\":\"Начална дата\",\"timeZoneName\":\"часова зона\",\"weekday\":\"ден от седмицата\",\"year\":\"година\"}");


var $151b77e0fd711730$exports = {};
$151b77e0fd711730$exports = JSON.parse("{\"calendar\":\"Kalendář\",\"day\":\"den\",\"dayPeriod\":\"část dne\",\"endDate\":\"Konečné datum\",\"era\":\"letopočet\",\"hour\":\"hodina\",\"minute\":\"minuta\",\"month\":\"měsíc\",\"second\":\"sekunda\",\"selectedDateDescription\":\"Vybrané datum: {date}\",\"selectedRangeDescription\":\"Vybrané období: {startDate} až {endDate}\",\"selectedTimeDescription\":\"Vybraný čas: {time}\",\"startDate\":\"Počáteční datum\",\"timeZoneName\":\"časové pásmo\",\"weekday\":\"den v týdnu\",\"year\":\"rok\"}");


var $61915aa8630b90a2$exports = {};
$61915aa8630b90a2$exports = JSON.parse("{\"calendar\":\"Kalender\",\"day\":\"dag\",\"dayPeriod\":\"AM/PM\",\"endDate\":\"Slutdato\",\"era\":\"æra\",\"hour\":\"time\",\"minute\":\"minut\",\"month\":\"måned\",\"second\":\"sekund\",\"selectedDateDescription\":\"Valgt dato: {date}\",\"selectedRangeDescription\":\"Valgt interval: {startDate} til {endDate}\",\"selectedTimeDescription\":\"Valgt tidspunkt: {time}\",\"startDate\":\"Startdato\",\"timeZoneName\":\"tidszone\",\"weekday\":\"ugedag\",\"year\":\"år\"}");


var $35cea00159787840$exports = {};
$35cea00159787840$exports = JSON.parse("{\"calendar\":\"Kalender\",\"day\":\"Tag\",\"dayPeriod\":\"Tageshälfte\",\"endDate\":\"Enddatum\",\"era\":\"Epoche\",\"hour\":\"Stunde\",\"minute\":\"Minute\",\"month\":\"Monat\",\"second\":\"Sekunde\",\"selectedDateDescription\":\"Ausgewähltes Datum: {date}\",\"selectedRangeDescription\":\"Ausgewählter Bereich: {startDate} bis {endDate}\",\"selectedTimeDescription\":\"Ausgewählte Zeit: {time}\",\"startDate\":\"Anfangsdatum\",\"timeZoneName\":\"Zeitzone\",\"weekday\":\"Wochentag\",\"year\":\"Jahr\"}");


var $518b4e82b9eacafd$exports = {};
$518b4e82b9eacafd$exports = JSON.parse("{\"calendar\":\"Ημερολόγιο\",\"day\":\"ημέρα\",\"dayPeriod\":\"π.μ./μ.μ.\",\"endDate\":\"Ημερομηνία λήξης\",\"era\":\"περίοδος\",\"hour\":\"ώρα\",\"minute\":\"λεπτό\",\"month\":\"μήνας\",\"second\":\"δευτερόλεπτο\",\"selectedDateDescription\":\"Επιλεγμένη ημερομηνία: {date}\",\"selectedRangeDescription\":\"Επιλεγμένο εύρος: {startDate} έως {endDate}\",\"selectedTimeDescription\":\"Επιλεγμένη ώρα: {time}\",\"startDate\":\"Ημερομηνία έναρξης\",\"timeZoneName\":\"ζώνη ώρας\",\"weekday\":\"καθημερινή\",\"year\":\"έτος\"}");


var $1c2b297f7e2cf474$exports = {};
$1c2b297f7e2cf474$exports = JSON.parse("{\"era\":\"era\",\"year\":\"year\",\"month\":\"month\",\"day\":\"day\",\"hour\":\"hour\",\"minute\":\"minute\",\"second\":\"second\",\"dayPeriod\":\"AM/PM\",\"calendar\":\"Calendar\",\"startDate\":\"Start Date\",\"endDate\":\"End Date\",\"weekday\":\"day of the week\",\"timeZoneName\":\"time zone\",\"selectedDateDescription\":\"Selected Date: {date}\",\"selectedRangeDescription\":\"Selected Range: {startDate} to {endDate}\",\"selectedTimeDescription\":\"Selected Time: {time}\"}");


var $07f628a707cf9b18$exports = {};
$07f628a707cf9b18$exports = JSON.parse("{\"calendar\":\"Calendario\",\"day\":\"día\",\"dayPeriod\":\"a. m./p. m.\",\"endDate\":\"Fecha final\",\"era\":\"era\",\"hour\":\"hora\",\"minute\":\"minuto\",\"month\":\"mes\",\"second\":\"segundo\",\"selectedDateDescription\":\"Fecha seleccionada: {date}\",\"selectedRangeDescription\":\"Rango seleccionado: {startDate} a {endDate}\",\"selectedTimeDescription\":\"Hora seleccionada: {time}\",\"startDate\":\"Fecha de inicio\",\"timeZoneName\":\"zona horaria\",\"weekday\":\"día de la semana\",\"year\":\"año\"}");


var $db553ffe17c7f4db$exports = {};
$db553ffe17c7f4db$exports = JSON.parse("{\"calendar\":\"Kalender\",\"day\":\"päev\",\"dayPeriod\":\"enne/pärast lõunat\",\"endDate\":\"Lõppkuupäev\",\"era\":\"ajastu\",\"hour\":\"tund\",\"minute\":\"minut\",\"month\":\"kuu\",\"second\":\"sekund\",\"selectedDateDescription\":\"Valitud kuupäev: {date}\",\"selectedRangeDescription\":\"Valitud vahemik: {startDate} kuni {endDate}\",\"selectedTimeDescription\":\"Valitud aeg: {time}\",\"startDate\":\"Alguskuupäev\",\"timeZoneName\":\"ajavöönd\",\"weekday\":\"nädalapäev\",\"year\":\"aasta\"}");


var $4afcfe00cd703f83$exports = {};
$4afcfe00cd703f83$exports = JSON.parse("{\"calendar\":\"Kalenteri\",\"day\":\"päivä\",\"dayPeriod\":\"vuorokaudenaika\",\"endDate\":\"Päättymispäivä\",\"era\":\"aikakausi\",\"hour\":\"tunti\",\"minute\":\"minuutti\",\"month\":\"kuukausi\",\"second\":\"sekunti\",\"selectedDateDescription\":\"Valittu päivämäärä: {date}\",\"selectedRangeDescription\":\"Valittu aikaväli: {startDate} – {endDate}\",\"selectedTimeDescription\":\"Valittu aika: {time}\",\"startDate\":\"Alkamispäivä\",\"timeZoneName\":\"aikavyöhyke\",\"weekday\":\"viikonpäivä\",\"year\":\"vuosi\"}");


var $1d2645d18d4c5be0$exports = {};
$1d2645d18d4c5be0$exports = JSON.parse("{\"calendar\":\"Calendrier\",\"day\":\"jour\",\"dayPeriod\":\"cadran\",\"endDate\":\"Date de fin\",\"era\":\"ère\",\"hour\":\"heure\",\"minute\":\"minute\",\"month\":\"mois\",\"second\":\"seconde\",\"selectedDateDescription\":\"Date sélectionnée : {date}\",\"selectedRangeDescription\":\"Plage sélectionnée : {startDate} au {endDate}\",\"selectedTimeDescription\":\"Heure choisie : {time}\",\"startDate\":\"Date de début\",\"timeZoneName\":\"fuseau horaire\",\"weekday\":\"jour de la semaine\",\"year\":\"année\"}");


var $64cb6a9be1f6fa48$exports = {};
$64cb6a9be1f6fa48$exports = JSON.parse("{\"calendar\":\"לוח שנה\",\"day\":\"יום\",\"dayPeriod\":\"לפנה״צ/אחה״צ\",\"endDate\":\"תאריך סיום\",\"era\":\"תקופה\",\"hour\":\"שעה\",\"minute\":\"דקה\",\"month\":\"חודש\",\"second\":\"שנייה\",\"selectedDateDescription\":\"תאריך נבחר: {date}\",\"selectedRangeDescription\":\"טווח נבחר: {startDate} עד {endDate}\",\"selectedTimeDescription\":\"זמן נבחר: {time}\",\"startDate\":\"תאריך התחלה\",\"timeZoneName\":\"אזור זמן\",\"weekday\":\"יום בשבוע\",\"year\":\"שנה\"}");


var $2a1ef2e8050be27a$exports = {};
$2a1ef2e8050be27a$exports = JSON.parse("{\"calendar\":\"Kalendar\",\"day\":\"dan\",\"dayPeriod\":\"AM/PM\",\"endDate\":\"Datum završetka\",\"era\":\"era\",\"hour\":\"sat\",\"minute\":\"minuta\",\"month\":\"mjesec\",\"second\":\"sekunda\",\"selectedDateDescription\":\"Odabrani datum: {date}\",\"selectedRangeDescription\":\"Odabrani raspon: {startDate} do {endDate}\",\"selectedTimeDescription\":\"Odabrano vrijeme: {time}\",\"startDate\":\"Datum početka\",\"timeZoneName\":\"vremenska zona\",\"weekday\":\"dan u tjednu\",\"year\":\"godina\"}");


var $ad429dca102acd0e$exports = {};
$ad429dca102acd0e$exports = JSON.parse("{\"calendar\":\"Naptár\",\"day\":\"nap\",\"dayPeriod\":\"napszak\",\"endDate\":\"Befejező dátum\",\"era\":\"éra\",\"hour\":\"óra\",\"minute\":\"perc\",\"month\":\"hónap\",\"second\":\"másodperc\",\"selectedDateDescription\":\"Kijelölt dátum: {date}\",\"selectedRangeDescription\":\"Kijelölt tartomány: {startDate}–{endDate}\",\"selectedTimeDescription\":\"Kijelölt idő: {time}\",\"startDate\":\"Kezdő dátum\",\"timeZoneName\":\"időzóna\",\"weekday\":\"hét napja\",\"year\":\"év\"}");


var $6e68cb5d1cb97bd2$exports = {};
$6e68cb5d1cb97bd2$exports = JSON.parse("{\"calendar\":\"Calendario\",\"day\":\"giorno\",\"dayPeriod\":\"AM/PM\",\"endDate\":\"Data finale\",\"era\":\"era\",\"hour\":\"ora\",\"minute\":\"minuto\",\"month\":\"mese\",\"second\":\"secondo\",\"selectedDateDescription\":\"Data selezionata: {date}\",\"selectedRangeDescription\":\"Intervallo selezionato: da {startDate} a {endDate}\",\"selectedTimeDescription\":\"Ora selezionata: {time}\",\"startDate\":\"Data iniziale\",\"timeZoneName\":\"fuso orario\",\"weekday\":\"giorno della settimana\",\"year\":\"anno\"}");


var $a82ee9af063ee069$exports = {};
$a82ee9af063ee069$exports = JSON.parse("{\"calendar\":\"カレンダー\",\"day\":\"日\",\"dayPeriod\":\"午前/午後\",\"endDate\":\"終了日\",\"era\":\"時代\",\"hour\":\"時\",\"minute\":\"分\",\"month\":\"月\",\"second\":\"秒\",\"selectedDateDescription\":\"選択した日付 : {date}\",\"selectedRangeDescription\":\"選択範囲 : {startDate} から {endDate}\",\"selectedTimeDescription\":\"選択した時間 : {time}\",\"startDate\":\"開始日\",\"timeZoneName\":\"タイムゾーン\",\"weekday\":\"曜日\",\"year\":\"年\"}");


var $67e9091dbf37d4eb$exports = {};
$67e9091dbf37d4eb$exports = JSON.parse("{\"calendar\":\"달력\",\"day\":\"일\",\"dayPeriod\":\"오전/오후\",\"endDate\":\"종료 날짜\",\"era\":\"연호\",\"hour\":\"시\",\"minute\":\"분\",\"month\":\"월\",\"second\":\"초\",\"selectedDateDescription\":\"선택 일자: {date}\",\"selectedRangeDescription\":\"선택 범위: {startDate} ~ {endDate}\",\"selectedTimeDescription\":\"선택 시간: {time}\",\"startDate\":\"시작 날짜\",\"timeZoneName\":\"시간대\",\"weekday\":\"요일\",\"year\":\"년\"}");


var $75834f9729f653d1$exports = {};
$75834f9729f653d1$exports = JSON.parse("{\"calendar\":\"Kalendorius\",\"day\":\"diena\",\"dayPeriod\":\"iki pietų / po pietų\",\"endDate\":\"Pabaigos data\",\"era\":\"era\",\"hour\":\"valanda\",\"minute\":\"minutė\",\"month\":\"mėnuo\",\"second\":\"sekundė\",\"selectedDateDescription\":\"Pasirinkta data: {date}\",\"selectedRangeDescription\":\"Pasirinktas intervalas: nuo {startDate} iki {endDate}\",\"selectedTimeDescription\":\"Pasirinktas laikas: {time}\",\"startDate\":\"Pradžios data\",\"timeZoneName\":\"laiko juosta\",\"weekday\":\"savaitės diena\",\"year\":\"metai\"}");


var $a2df2c2520b4a7f0$exports = {};
$a2df2c2520b4a7f0$exports = JSON.parse("{\"calendar\":\"Kalendārs\",\"day\":\"diena\",\"dayPeriod\":\"priekšpusdienā/pēcpusdienā\",\"endDate\":\"Beigu datums\",\"era\":\"ēra\",\"hour\":\"stundas\",\"minute\":\"minūtes\",\"month\":\"mēnesis\",\"second\":\"sekundes\",\"selectedDateDescription\":\"Atlasītais datums: {date}\",\"selectedRangeDescription\":\"Atlasītais diapazons: no {startDate} līdz {endDate}\",\"selectedTimeDescription\":\"Atlasītais laiks: {time}\",\"startDate\":\"Sākuma datums\",\"timeZoneName\":\"laika josla\",\"weekday\":\"nedēļas diena\",\"year\":\"gads\"}");


var $aedcd71db4933ed5$exports = {};
$aedcd71db4933ed5$exports = JSON.parse("{\"calendar\":\"Kalender\",\"day\":\"dag\",\"dayPeriod\":\"a.m./p.m.\",\"endDate\":\"Sluttdato\",\"era\":\"tidsalder\",\"hour\":\"time\",\"minute\":\"minutt\",\"month\":\"måned\",\"second\":\"sekund\",\"selectedDateDescription\":\"Valgt dato: {date}\",\"selectedRangeDescription\":\"Valgt område: {startDate} til {endDate}\",\"selectedTimeDescription\":\"Valgt tid: {time}\",\"startDate\":\"Startdato\",\"timeZoneName\":\"tidssone\",\"weekday\":\"ukedag\",\"year\":\"år\"}");


var $3b2df9e54353046c$exports = {};
$3b2df9e54353046c$exports = JSON.parse("{\"calendar\":\"Kalender\",\"day\":\"dag\",\"dayPeriod\":\"a.m./p.m.\",\"endDate\":\"Einddatum\",\"era\":\"tijdperk\",\"hour\":\"uur\",\"minute\":\"minuut\",\"month\":\"maand\",\"second\":\"seconde\",\"selectedDateDescription\":\"Geselecteerde datum: {date}\",\"selectedRangeDescription\":\"Geselecteerd bereik: {startDate} tot {endDate}\",\"selectedTimeDescription\":\"Geselecteerde tijd: {time}\",\"startDate\":\"Startdatum\",\"timeZoneName\":\"tijdzone\",\"weekday\":\"dag van de week\",\"year\":\"jaar\"}");


var $c03fe977fcfafe93$exports = {};
$c03fe977fcfafe93$exports = JSON.parse("{\"calendar\":\"Kalendarz\",\"day\":\"dzień\",\"dayPeriod\":\"rano / po południu / wieczorem\",\"endDate\":\"Data końcowa\",\"era\":\"era\",\"hour\":\"godzina\",\"minute\":\"minuta\",\"month\":\"miesiąc\",\"second\":\"sekunda\",\"selectedDateDescription\":\"Wybrana data: {date}\",\"selectedRangeDescription\":\"Wybrany zakres: {startDate} do {endDate}\",\"selectedTimeDescription\":\"Wybrany czas: {time}\",\"startDate\":\"Data początkowa\",\"timeZoneName\":\"strefa czasowa\",\"weekday\":\"dzień tygodnia\",\"year\":\"rok\"}");


var $569f006fc292345f$exports = {};
$569f006fc292345f$exports = JSON.parse("{\"calendar\":\"Calendário\",\"day\":\"dia\",\"dayPeriod\":\"AM/PM\",\"endDate\":\"Data final\",\"era\":\"era\",\"hour\":\"hora\",\"minute\":\"minuto\",\"month\":\"mês\",\"second\":\"segundo\",\"selectedDateDescription\":\"Data selecionada: {date}\",\"selectedRangeDescription\":\"Intervalo selecionado: {startDate} a {endDate}\",\"selectedTimeDescription\":\"Hora selecionada: {time}\",\"startDate\":\"Data inicial\",\"timeZoneName\":\"fuso horário\",\"weekday\":\"dia da semana\",\"year\":\"ano\"}");


var $7c2494e14452f2dd$exports = {};
$7c2494e14452f2dd$exports = JSON.parse("{\"calendar\":\"Calendário\",\"day\":\"dia\",\"dayPeriod\":\"am/pm\",\"endDate\":\"Data de Término\",\"era\":\"era\",\"hour\":\"hora\",\"minute\":\"minuto\",\"month\":\"mês\",\"second\":\"segundo\",\"selectedDateDescription\":\"Data selecionada: {date}\",\"selectedRangeDescription\":\"Intervalo selecionado: {startDate} a {endDate}\",\"selectedTimeDescription\":\"Hora selecionada: {time}\",\"startDate\":\"Data de Início\",\"timeZoneName\":\"fuso horário\",\"weekday\":\"dia da semana\",\"year\":\"ano\"}");


var $eb82ef981b5592bf$exports = {};
$eb82ef981b5592bf$exports = JSON.parse("{\"calendar\":\"Calendar\",\"day\":\"zi\",\"dayPeriod\":\"a.m/p.m.\",\"endDate\":\"Dată final\",\"era\":\"eră\",\"hour\":\"oră\",\"minute\":\"minut\",\"month\":\"lună\",\"second\":\"secundă\",\"selectedDateDescription\":\"Dată selectată: {date}\",\"selectedRangeDescription\":\"Interval selectat: de la {startDate} până la {endDate}\",\"selectedTimeDescription\":\"Ora selectată: {time}\",\"startDate\":\"Dată început\",\"timeZoneName\":\"fus orar\",\"weekday\":\"ziua din săptămână\",\"year\":\"an\"}");


var $6efa0e119f396950$exports = {};
$6efa0e119f396950$exports = JSON.parse("{\"calendar\":\"Календарь\",\"day\":\"день\",\"dayPeriod\":\"AM/PM\",\"endDate\":\"Дата окончания\",\"era\":\"эра\",\"hour\":\"час\",\"minute\":\"минута\",\"month\":\"месяц\",\"second\":\"секунда\",\"selectedDateDescription\":\"Выбранная дата: {date}\",\"selectedRangeDescription\":\"Выбранный диапазон: с {startDate} по {endDate}\",\"selectedTimeDescription\":\"Выбранное время: {time}\",\"startDate\":\"Дата начала\",\"timeZoneName\":\"часовой пояс\",\"weekday\":\"день недели\",\"year\":\"год\"}");


var $7f5e57085d7f5049$exports = {};
$7f5e57085d7f5049$exports = JSON.parse("{\"calendar\":\"Kalendár\",\"day\":\"deň\",\"dayPeriod\":\"AM/PM\",\"endDate\":\"Dátum ukončenia\",\"era\":\"letopočet\",\"hour\":\"hodina\",\"minute\":\"minúta\",\"month\":\"mesiac\",\"second\":\"sekunda\",\"selectedDateDescription\":\"Vybratý dátum: {date}\",\"selectedRangeDescription\":\"Vybratý rozsah: od {startDate} do {endDate}\",\"selectedTimeDescription\":\"Vybratý čas: {time}\",\"startDate\":\"Dátum začatia\",\"timeZoneName\":\"časové pásmo\",\"weekday\":\"deň týždňa\",\"year\":\"rok\"}");


var $578ee7c11dcdde7a$exports = {};
$578ee7c11dcdde7a$exports = JSON.parse("{\"calendar\":\"Koledar\",\"day\":\"dan\",\"dayPeriod\":\"dop/pop\",\"endDate\":\"Datum konca\",\"era\":\"doba\",\"hour\":\"ura\",\"minute\":\"minuta\",\"month\":\"mesec\",\"second\":\"sekunda\",\"selectedDateDescription\":\"Izbrani datum: {date}\",\"selectedRangeDescription\":\"Izbrano območje: {startDate} do {endDate}\",\"selectedTimeDescription\":\"Izbrani čas: {time}\",\"startDate\":\"Datum začetka\",\"timeZoneName\":\"časovni pas\",\"weekday\":\"dan v tednu\",\"year\":\"leto\"}");


var $bbc3fd6cd0bc9d50$exports = {};
$bbc3fd6cd0bc9d50$exports = JSON.parse("{\"calendar\":\"Kalendar\",\"day\":\"дан\",\"dayPeriod\":\"пре подне/по подне\",\"endDate\":\"Datum završetka\",\"era\":\"ера\",\"hour\":\"сат\",\"minute\":\"минут\",\"month\":\"месец\",\"second\":\"секунд\",\"selectedDateDescription\":\"Izabrani datum: {date}\",\"selectedRangeDescription\":\"Izabrani opseg: od {startDate} do {endDate}\",\"selectedTimeDescription\":\"Izabrano vreme: {time}\",\"startDate\":\"Datum početka\",\"timeZoneName\":\"временска зона\",\"weekday\":\"дан у недељи\",\"year\":\"година\"}");


var $0b04512118591d2a$exports = {};
$0b04512118591d2a$exports = JSON.parse("{\"calendar\":\"Kalender\",\"day\":\"dag\",\"dayPeriod\":\"fm/em\",\"endDate\":\"Slutdatum\",\"era\":\"era\",\"hour\":\"timme\",\"minute\":\"minut\",\"month\":\"månad\",\"second\":\"sekund\",\"selectedDateDescription\":\"Valt datum: {date}\",\"selectedRangeDescription\":\"Valt intervall: {startDate} till {endDate}\",\"selectedTimeDescription\":\"Vald tid: {time}\",\"startDate\":\"Startdatum\",\"timeZoneName\":\"tidszon\",\"weekday\":\"veckodag\",\"year\":\"år\"}");


var $3a49d121fe4c9e1d$exports = {};
$3a49d121fe4c9e1d$exports = JSON.parse("{\"calendar\":\"Takvim\",\"day\":\"gün\",\"dayPeriod\":\"ÖÖ/ÖS\",\"endDate\":\"Bitiş Tarihi\",\"era\":\"çağ\",\"hour\":\"saat\",\"minute\":\"dakika\",\"month\":\"ay\",\"second\":\"saniye\",\"selectedDateDescription\":\"Seçilen Tarih: {date}\",\"selectedRangeDescription\":\"Seçilen Aralık: {startDate} - {endDate}\",\"selectedTimeDescription\":\"Seçilen Zaman: {time}\",\"startDate\":\"Başlangıç Tarihi\",\"timeZoneName\":\"saat dilimi\",\"weekday\":\"haftanın günü\",\"year\":\"yıl\"}");


var $5ba21dbb8914919d$exports = {};
$5ba21dbb8914919d$exports = JSON.parse("{\"calendar\":\"Календар\",\"day\":\"день\",\"dayPeriod\":\"дп/пп\",\"endDate\":\"Дата завершення\",\"era\":\"ера\",\"hour\":\"година\",\"minute\":\"хвилина\",\"month\":\"місяць\",\"second\":\"секунда\",\"selectedDateDescription\":\"Вибрана дата: {date}\",\"selectedRangeDescription\":\"Вибраний діапазон: {startDate} — {endDate}\",\"selectedTimeDescription\":\"Вибраний час: {time}\",\"startDate\":\"Дата початку\",\"timeZoneName\":\"часовий пояс\",\"weekday\":\"день тижня\",\"year\":\"рік\"}");


var $51078838e1b16cd7$exports = {};
$51078838e1b16cd7$exports = JSON.parse("{\"calendar\":\"日历\",\"day\":\"日\",\"dayPeriod\":\"上午/下午\",\"endDate\":\"结束日期\",\"era\":\"纪元\",\"hour\":\"小时\",\"minute\":\"分钟\",\"month\":\"月\",\"second\":\"秒\",\"selectedDateDescription\":\"选定的日期：{date}\",\"selectedRangeDescription\":\"选定的范围：{startDate} 至 {endDate}\",\"selectedTimeDescription\":\"选定的时间：{time}\",\"startDate\":\"开始日期\",\"timeZoneName\":\"时区\",\"weekday\":\"工作日\",\"year\":\"年\"}");


var $33fab8219207655a$exports = {};
$33fab8219207655a$exports = JSON.parse("{\"calendar\":\"日曆\",\"day\":\"日\",\"dayPeriod\":\"上午/下午\",\"endDate\":\"結束日期\",\"era\":\"纪元\",\"hour\":\"小时\",\"minute\":\"分钟\",\"month\":\"月\",\"second\":\"秒\",\"selectedDateDescription\":\"選定的日期：{date}\",\"selectedRangeDescription\":\"選定的範圍：{startDate} 至 {endDate}\",\"selectedTimeDescription\":\"選定的時間：{time}\",\"startDate\":\"開始日期\",\"timeZoneName\":\"时区\",\"weekday\":\"工作日\",\"year\":\"年\"}");


$204383cf4f6b0d06$exports = {
    "ar-AE": $f23889fffbde9058$exports,
    "bg-BG": $09d9badaa8903929$exports,
    "cs-CZ": $151b77e0fd711730$exports,
    "da-DK": $61915aa8630b90a2$exports,
    "de-DE": $35cea00159787840$exports,
    "el-GR": $518b4e82b9eacafd$exports,
    "en-US": $1c2b297f7e2cf474$exports,
    "es-ES": $07f628a707cf9b18$exports,
    "et-EE": $db553ffe17c7f4db$exports,
    "fi-FI": $4afcfe00cd703f83$exports,
    "fr-FR": $1d2645d18d4c5be0$exports,
    "he-IL": $64cb6a9be1f6fa48$exports,
    "hr-HR": $2a1ef2e8050be27a$exports,
    "hu-HU": $ad429dca102acd0e$exports,
    "it-IT": $6e68cb5d1cb97bd2$exports,
    "ja-JP": $a82ee9af063ee069$exports,
    "ko-KR": $67e9091dbf37d4eb$exports,
    "lt-LT": $75834f9729f653d1$exports,
    "lv-LV": $a2df2c2520b4a7f0$exports,
    "nb-NO": $aedcd71db4933ed5$exports,
    "nl-NL": $3b2df9e54353046c$exports,
    "pl-PL": $c03fe977fcfafe93$exports,
    "pt-BR": $569f006fc292345f$exports,
    "pt-PT": $7c2494e14452f2dd$exports,
    "ro-RO": $eb82ef981b5592bf$exports,
    "ru-RU": $6efa0e119f396950$exports,
    "sk-SK": $7f5e57085d7f5049$exports,
    "sl-SI": $578ee7c11dcdde7a$exports,
    "sr-SP": $bbc3fd6cd0bc9d50$exports,
    "sv-SE": $0b04512118591d2a$exports,
    "tr-TR": $3a49d121fe4c9e1d$exports,
    "uk-UA": $5ba21dbb8914919d$exports,
    "zh-CN": $51078838e1b16cd7$exports,
    "zh-TW": $33fab8219207655a$exports
};











function $3dfb0f96be0d6a08$export$4a931266a3838b86(state, ref1, disableArrowNavigation) {
    let { direction: direction  } = $cIPI0$useLocale();
    let focusManager = $cIPI0$useMemo(()=>$cIPI0$createFocusManager(ref1)
    , [
        ref1
    ]);
    // Open the popover on alt + arrow down
    let onKeyDown = (e)=>{
        if (e.altKey && (e.key === 'ArrowDown' || e.key === 'ArrowUp') && 'setOpen' in state) {
            e.preventDefault();
            e.stopPropagation();
            state.setOpen(true);
        }
        if (disableArrowNavigation) return;
        switch(e.key){
            case 'ArrowLeft':
                e.preventDefault();
                e.stopPropagation();
                if (direction === 'rtl') focusManager.focusNext();
                else focusManager.focusPrevious();
                break;
            case 'ArrowRight':
                e.preventDefault();
                e.stopPropagation();
                if (direction === 'rtl') focusManager.focusPrevious();
                else focusManager.focusNext();
                break;
        }
    };
    // Focus the first placeholder segment from the end on mouse down/touch up in the field.
    let focusLast = ()=>{
        var ref;
        // Try to find the segment prior to the element that was clicked on.
        let target = (ref = window.event) === null || ref === void 0 ? void 0 : ref.target;
        let walker = $cIPI0$getFocusableTreeWalker(ref1.current, {
            tabbable: true
        });
        if (target) {
            walker.currentNode = target;
            target = walker.previousNode();
        }
        // If no target found, find the last element from the end.
        if (!target) {
            let last;
            do {
                last = walker.lastChild();
                if (last) target = last;
            }while (last)
        }
        // Now go backwards until we find an element that is not a placeholder.
        while(target === null || target === void 0 ? void 0 : target.hasAttribute('data-placeholder')){
            let prev = walker.previousNode();
            if (prev && prev.hasAttribute('data-placeholder')) target = prev;
            else break;
        }
        if (target) target.focus();
    };
    let { pressProps: pressProps  } = $cIPI0$usePress({
        onPressStart (e) {
            if (e.pointerType === 'mouse') focusLast();
        },
        onPress (e) {
            if (e.pointerType !== 'mouse') focusLast();
        }
    });
    return $cIPI0$mergeProps(pressProps, {
        onKeyDown: onKeyDown
    });
}





const $16f0b7bb276bc17e$export$653eddfc964b0f8a = new WeakMap();
const $16f0b7bb276bc17e$export$300019f83c56d282 = '__role_' + Date.now();
const $16f0b7bb276bc17e$export$7b3062cd49e80452 = '__focusManager_' + Date.now();
function $16f0b7bb276bc17e$export$5591b0b878c1a989(props, state, ref) {
    let { labelProps: labelProps , fieldProps: fieldProps , descriptionProps: descriptionProps , errorMessageProps: errorMessageProps  } = $cIPI0$useField({
        ...props,
        labelElementType: 'span'
    });
    let { focusWithinProps: focusWithinProps  } = $cIPI0$useFocusWithin({
        onBlurWithin () {
            state.confirmPlaceholder();
        }
    });
    let formatMessage = $cIPI0$useMessageFormatter((/*@__PURE__*/$parcel$interopDefault($204383cf4f6b0d06$exports)));
    let message = state.maxGranularity === 'hour' ? 'selectedTimeDescription' : 'selectedDateDescription';
    let field = state.maxGranularity === 'hour' ? 'time' : 'date';
    let description = state.value ? formatMessage(message, {
        [field]: state.formatValue({
            month: 'long'
        })
    }) : '';
    let descProps = $cIPI0$useDescription(description);
    // If within a date picker or date range picker, the date field will have role="presentation" and an aria-describedby
    // will be passed in that references the value (e.g. entire range). Otherwise, add the field's value description.
    let describedBy = props[$16f0b7bb276bc17e$export$300019f83c56d282] === 'presentation' ? fieldProps['aria-describedby'] : [
        descProps['aria-describedby'],
        fieldProps['aria-describedby']
    ].filter(Boolean).join(' ') || undefined;
    let propsFocusManager = props[$16f0b7bb276bc17e$export$7b3062cd49e80452];
    let focusManager = $cIPI0$useMemo(()=>propsFocusManager || $cIPI0$createFocusManager(ref)
    , [
        propsFocusManager,
        ref
    ]);
    let groupProps = $3dfb0f96be0d6a08$export$4a931266a3838b86(state, ref, props[$16f0b7bb276bc17e$export$300019f83c56d282] === 'presentation');
    // Pass labels and other information to segments.
    $16f0b7bb276bc17e$export$653eddfc964b0f8a.set(state, {
        ariaLabel: props['aria-label'],
        ariaLabelledBy: [
            props['aria-labelledby'],
            labelProps.id
        ].filter(Boolean).join(' ') || undefined,
        ariaDescribedBy: describedBy,
        focusManager: focusManager
    });
    let autoFocusRef = $cIPI0$useRef(props.autoFocus);
    // When used within a date picker or date range picker, the field gets role="presentation"
    // rather than role="group". Since the date picker/date range picker already has a role="group"
    // with a label and description, and the segments are already labeled by this as well, this
    // avoids very verbose duplicate announcements.
    let fieldDOMProps;
    if (props[$16f0b7bb276bc17e$export$300019f83c56d282] === 'presentation') fieldDOMProps = {
        role: 'presentation'
    };
    else fieldDOMProps = $cIPI0$mergeProps(fieldProps, {
        role: 'group',
        'aria-disabled': props.isDisabled || undefined,
        'aria-describedby': describedBy
    });
    $cIPI0$useEffect(()=>{
        if (autoFocusRef.current) focusManager.focusFirst();
        autoFocusRef.current = false;
    }, [
        focusManager
    ]);
    let domProps = $cIPI0$filterDOMProps(props);
    return {
        labelProps: {
            ...labelProps,
            onClick: ()=>{
                focusManager.focusFirst();
            }
        },
        fieldProps: $cIPI0$mergeProps(domProps, fieldDOMProps, groupProps, focusWithinProps),
        descriptionProps: descriptionProps,
        errorMessageProps: errorMessageProps
    };
}
function $16f0b7bb276bc17e$export$4c842f6a241dc825(props, state, ref) {
    return $16f0b7bb276bc17e$export$5591b0b878c1a989(props, state, ref);
}





function $6057a3d2a53a12fd$export$42df105a73306d51(props, state, ref) {
    let buttonId = $cIPI0$useId();
    let dialogId = $cIPI0$useId();
    let formatMessage = $cIPI0$useMessageFormatter((/*@__PURE__*/$parcel$interopDefault($204383cf4f6b0d06$exports)));
    let { labelProps: labelProps , fieldProps: fieldProps , descriptionProps: descriptionProps , errorMessageProps: errorMessageProps  } = $cIPI0$useField({
        ...props,
        labelElementType: 'span'
    });
    let groupProps = $3dfb0f96be0d6a08$export$4a931266a3838b86(state, ref);
    let labelledBy = fieldProps['aria-labelledby'] || fieldProps.id;
    let { locale: locale  } = $cIPI0$useLocale();
    let date = state.formatValue(locale, {
        month: 'long'
    });
    let description = date ? formatMessage('selectedDateDescription', {
        date: date
    }) : '';
    let descProps = $cIPI0$useDescription(description);
    let ariaDescribedBy = [
        descProps['aria-describedby'],
        fieldProps['aria-describedby']
    ].filter(Boolean).join(' ') || undefined;
    let domProps = $cIPI0$filterDOMProps(props);
    let focusManager = $cIPI0$useMemo(()=>$cIPI0$createFocusManager(ref)
    , [
        ref
    ]);
    return {
        groupProps: $cIPI0$mergeProps(domProps, groupProps, fieldProps, descProps, {
            role: 'group',
            'aria-disabled': props.isDisabled || null,
            'aria-labelledby': labelledBy,
            'aria-describedby': ariaDescribedBy
        }),
        labelProps: {
            ...labelProps,
            onClick: ()=>{
                focusManager.focusFirst();
            }
        },
        fieldProps: {
            ...fieldProps,
            [$16f0b7bb276bc17e$export$300019f83c56d282]: 'presentation',
            'aria-describedby': ariaDescribedBy,
            value: state.value,
            onChange: state.setValue,
            minValue: props.minValue,
            maxValue: props.maxValue,
            placeholderValue: props.placeholderValue,
            hideTimeZone: props.hideTimeZone,
            hourCycle: props.hourCycle,
            granularity: props.granularity,
            isDisabled: props.isDisabled,
            isReadOnly: props.isReadOnly,
            isRequired: props.isRequired,
            validationState: state.validationState,
            autoFocus: props.autoFocus
        },
        descriptionProps: descriptionProps,
        errorMessageProps: errorMessageProps,
        buttonProps: {
            ...descProps,
            id: buttonId,
            'aria-haspopup': 'dialog',
            'aria-label': formatMessage('calendar'),
            'aria-labelledby': `${labelledBy} ${buttonId}`,
            'aria-describedby': ariaDescribedBy,
            onPress: ()=>state.setOpen(true)
        },
        dialogProps: {
            id: dialogId,
            'aria-labelledby': `${labelledBy} ${buttonId}`
        },
        calendarProps: {
            autoFocus: true,
            value: state.dateValue,
            onChange: state.setDateValue,
            minValue: props.minValue,
            maxValue: props.maxValue,
            isDisabled: props.isDisabled,
            isReadOnly: props.isReadOnly,
            isDateUnavailable: props.isDateUnavailable,
            defaultFocusedValue: state.dateValue ? undefined : props.placeholderValue,
            validationState: state.validationState,
            errorMessage: props.errorMessage
        }
    };
}












function $3aeceb3a64eb8358$export$d42c60378c8168f8() {
    let { locale: locale  } = $cIPI0$useLocale();
    return $cIPI0$useMemo(()=>{
        // Try to use Intl.DisplayNames if possible. It may be supported in browsers, but not support the dateTimeField
        // type as that was only added in v2. https://github.com/tc39/intl-displaynames-v2
        try {
            // @ts-ignore
            return new Intl.DisplayNames(locale, {
                type: 'dateTimeField'
            });
        } catch (err) {
            return new $3aeceb3a64eb8358$var$DisplayNamesPolyfill(locale);
        }
    }, [
        locale
    ]);
}
class $3aeceb3a64eb8358$var$DisplayNamesPolyfill {
    of(field) {
        return this.dictionary.getStringForLocale(field, this.locale);
    }
    constructor(locale){
        this.locale = locale;
        this.dictionary = new $cIPI0$MessageDictionary((/*@__PURE__*/$parcel$interopDefault($204383cf4f6b0d06$exports)));
    }
}



function $32489daedd52963e$export$1315d136e6f7581(segment, state, ref) {
    let enteredKeys = $cIPI0$useRef('');
    let { locale: locale  } = $cIPI0$useLocale();
    let displayNames = $3aeceb3a64eb8358$export$d42c60378c8168f8();
    let { ariaLabel: ariaLabel , ariaLabelledBy: ariaLabelledBy , ariaDescribedBy: ariaDescribedBy , focusManager: focusManager  } = $16f0b7bb276bc17e$export$653eddfc964b0f8a.get(state);
    let textValue = segment.isPlaceholder ? '' : segment.text;
    let options = $cIPI0$useMemo(()=>state.dateFormatter.resolvedOptions()
    , [
        state.dateFormatter
    ]);
    let monthDateFormatter = $cIPI0$useDateFormatter({
        month: 'long',
        timeZone: options.timeZone
    });
    let hourDateFormatter = $cIPI0$useDateFormatter({
        hour: 'numeric',
        hour12: options.hour12,
        timeZone: options.timeZone
    });
    if (segment.type === 'month' && !segment.isPlaceholder) {
        let monthTextValue = monthDateFormatter.format(state.dateValue);
        textValue = monthTextValue !== textValue ? `${textValue} – ${monthTextValue}` : monthTextValue;
    } else if (segment.type === 'hour' && !segment.isPlaceholder) textValue = hourDateFormatter.format(state.dateValue);
    let { spinButtonProps: spinButtonProps  } = $cIPI0$useSpinButton({
        // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.
        // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.
        // https://github.com/dequelabs/axe-core/issues/3505
        value: segment.value,
        textValue: textValue,
        minValue: segment.minValue,
        maxValue: segment.maxValue,
        isDisabled: state.isDisabled,
        isReadOnly: state.isReadOnly || !segment.isEditable,
        isRequired: state.isRequired,
        onIncrement: ()=>{
            enteredKeys.current = '';
            state.increment(segment.type);
        },
        onDecrement: ()=>{
            enteredKeys.current = '';
            state.decrement(segment.type);
        },
        onIncrementPage: ()=>{
            enteredKeys.current = '';
            state.incrementPage(segment.type);
        },
        onDecrementPage: ()=>{
            enteredKeys.current = '';
            state.decrementPage(segment.type);
        },
        onIncrementToMax: ()=>{
            enteredKeys.current = '';
            state.setSegment(segment.type, segment.maxValue);
        },
        onDecrementToMin: ()=>{
            enteredKeys.current = '';
            state.setSegment(segment.type, segment.minValue);
        }
    });
    let parser = $cIPI0$useMemo(()=>new $cIPI0$NumberParser(locale, {
            maximumFractionDigits: 0
        })
    , [
        locale
    ]);
    let backspace = ()=>{
        if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly && !segment.isPlaceholder) {
            let newValue = segment.text.slice(0, -1);
            let parsed = parser.parse(newValue);
            if (newValue.length === 0 || parsed === 0) state.clearSegment(segment.type);
            else state.setSegment(segment.type, parsed);
            enteredKeys.current = newValue;
        } else if (segment.type === 'dayPeriod') state.clearSegment(segment.type);
    };
    let onKeyDown = (e)=>{
        // Firefox does not fire selectstart for Ctrl/Cmd + A
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1742153
        if (e.key === 'a' && ($cIPI0$isMac() ? e.metaKey : e.ctrlKey)) e.preventDefault();
        if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) return;
        switch(e.key){
            case 'Backspace':
            case 'Delete':
                // Safari on iOS does not fire beforeinput for the backspace key because the cursor is at the start.
                e.preventDefault();
                e.stopPropagation();
                backspace();
                break;
        }
    };
    // Safari dayPeriod option doesn't work...
    let { startsWith: startsWith  } = $cIPI0$useFilter({
        sensitivity: 'base'
    });
    let amPmFormatter = $cIPI0$useDateFormatter({
        hour: 'numeric',
        hour12: true
    });
    let am = $cIPI0$useMemo(()=>{
        let date = new Date();
        date.setHours(0);
        return amPmFormatter.formatToParts(date).find((part)=>part.type === 'dayPeriod'
        ).value;
    }, [
        amPmFormatter
    ]);
    let pm = $cIPI0$useMemo(()=>{
        let date = new Date();
        date.setHours(12);
        return amPmFormatter.formatToParts(date).find((part)=>part.type === 'dayPeriod'
        ).value;
    }, [
        amPmFormatter
    ]);
    // Get a list of formatted era names so users can type the first character to choose one.
    let eraFormatter = $cIPI0$useDateFormatter({
        year: 'numeric',
        era: 'narrow',
        timeZone: 'UTC'
    });
    let eras1 = $cIPI0$useMemo(()=>{
        if (segment.type !== 'era') return [];
        let date = $cIPI0$toCalendar(new $cIPI0$CalendarDate(1, 1, 1), state.calendar);
        let eras = state.calendar.getEras().map((era)=>{
            let eraDate = date.set({
                year: 1,
                month: 1,
                day: 1,
                era: era
            }).toDate('UTC');
            let parts = eraFormatter.formatToParts(eraDate);
            let formatted = parts.find((p)=>p.type === 'era'
            ).value;
            return {
                era: era,
                formatted: formatted
            };
        });
        // Remove the common prefix from formatted values. This is so that in calendars with eras like
        // ERA0 and ERA1 (e.g. Ethiopic), users can press "0" and "1" to select an era. In other cases,
        // the first letter is used.
        let prefixLength = $32489daedd52963e$var$commonPrefixLength(eras.map((era)=>era.formatted
        ));
        if (prefixLength) for (let era1 of eras)era1.formatted = era1.formatted.slice(prefixLength);
        return eras;
    }, [
        eraFormatter,
        state.calendar,
        segment.type
    ]);
    let onInput = (key)=>{
        if (state.isDisabled || state.isReadOnly) return;
        let newValue = enteredKeys.current + key;
        switch(segment.type){
            case 'dayPeriod':
                if (startsWith(am, key)) state.setSegment('dayPeriod', 0);
                else if (startsWith(pm, key)) state.setSegment('dayPeriod', 12);
                else break;
                focusManager.focusNext();
                break;
            case 'era':
                {
                    let matched = eras1.find((e)=>startsWith(e.formatted, key)
                    );
                    if (matched) {
                        state.setSegment('era', matched.era);
                        focusManager.focusNext();
                    }
                    break;
                }
            case 'day':
            case 'hour':
            case 'minute':
            case 'second':
            case 'month':
            case 'year':
                {
                    if (!parser.isValidPartialNumber(newValue)) return;
                    let numberValue = parser.parse(newValue);
                    let segmentValue = numberValue;
                    let allowsZero = segment.minValue === 0;
                    if (segment.type === 'hour' && state.dateFormatter.resolvedOptions().hour12) {
                        switch(state.dateFormatter.resolvedOptions().hourCycle){
                            case 'h11':
                                if (numberValue > 11) segmentValue = parser.parse(key);
                                break;
                            case 'h12':
                                allowsZero = false;
                                if (numberValue > 12) segmentValue = parser.parse(key);
                                break;
                        }
                        if (segment.value >= 12 && numberValue > 1) numberValue += 12;
                    } else if (numberValue > segment.maxValue) segmentValue = parser.parse(key);
                    if (isNaN(numberValue)) return;
                    let shouldSetValue = segmentValue !== 0 || allowsZero;
                    if (shouldSetValue) state.setSegment(segment.type, segmentValue);
                    if (Number(numberValue + '0') > segment.maxValue || newValue.length >= String(segment.maxValue).length) {
                        enteredKeys.current = '';
                        if (shouldSetValue) focusManager.focusNext();
                    } else enteredKeys.current = newValue;
                    break;
                }
        }
    };
    let onFocus = ()=>{
        enteredKeys.current = '';
        $cIPI0$scrollIntoView($cIPI0$getScrollParent(ref.current), ref.current);
        // Collapse selection to start or Chrome won't fire input events.
        let selection = window.getSelection();
        selection.collapse(ref.current);
    };
    let compositionRef = $cIPI0$useRef('');
    // @ts-ignore - TODO: possibly old TS version? doesn't fail in my editor...
    $cIPI0$useEvent(ref, 'beforeinput', (e)=>{
        e.preventDefault();
        switch(e.inputType){
            case 'deleteContentBackward':
            case 'deleteContentForward':
                if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly) backspace();
                break;
            case 'insertCompositionText':
                // insertCompositionText cannot be canceled.
                // Record the current state of the element so we can restore it in the `input` event below.
                compositionRef.current = ref.current.textContent;
                // Safari gets stuck in a composition state unless we also assign to the value here.
                // eslint-disable-next-line no-self-assign
                ref.current.textContent = ref.current.textContent;
                break;
            default:
                if (e.data != null) onInput(e.data);
                break;
        }
    });
    $cIPI0$useEvent(ref, 'input', (e)=>{
        let { inputType: inputType , data: data  } = e;
        switch(inputType){
            case 'insertCompositionText':
                // Reset the DOM to how it was in the beforeinput event.
                ref.current.textContent = compositionRef.current;
                // Android sometimes fires key presses of letters as composition events. Need to handle am/pm keys here too.
                // Can also happen e.g. with Pinyin keyboard on iOS.
                if (startsWith(am, data) || startsWith(pm, data)) onInput(data);
                break;
        }
    });
    $cIPI0$useLayoutEffect(()=>{
        let element = ref.current;
        return ()=>{
            // If the focused segment is removed, focus the previous one, or the next one if there was no previous one.
            if (document.activeElement === element) {
                let prev = focusManager.focusPrevious();
                if (!prev) focusManager.focusNext();
            }
        };
    }, [
        ref,
        focusManager
    ]);
    // spinbuttons cannot be focused with VoiceOver on iOS.
    let touchPropOverrides = $cIPI0$isIOS() || segment.type === 'timeZoneName' ? {
        role: 'textbox',
        'aria-valuemax': null,
        'aria-valuemin': null,
        'aria-valuetext': null,
        'aria-valuenow': null
    } : {
    };
    // Only apply aria-describedby to the first segment, unless the field is invalid. This avoids it being
    // read every time the user navigates to a new segment.
    let firstSegment = $cIPI0$useMemo(()=>state.segments.find((s)=>s.isEditable
        )
    , [
        state.segments
    ]);
    if (segment !== firstSegment && state.validationState !== 'invalid') ariaDescribedBy = undefined;
    let id = $cIPI0$useId();
    let isEditable = !state.isDisabled && !state.isReadOnly && segment.isEditable;
    // Prepend the label passed from the field to each segment name.
    // This is needed because VoiceOver on iOS does not announce groups.
    let name = segment.type === 'literal' ? '' : displayNames.of(segment.type);
    let labelProps = $cIPI0$useLabels({
        'aria-label': (ariaLabel ? ariaLabel + ' ' : '') + name,
        'aria-labelledby': ariaLabelledBy
    });
    // Literal segments should not be visible to screen readers. We don't really need any of the above,
    // but the rules of hooks mean hooks cannot be conditional so we have to put this condition here.
    if (segment.type === 'literal') return {
        segmentProps: {
            'aria-hidden': true
        }
    };
    return {
        segmentProps: $cIPI0$mergeProps(spinButtonProps, labelProps, {
            id: id,
            ...touchPropOverrides,
            'aria-invalid': state.validationState === 'invalid' ? 'true' : undefined,
            'aria-describedby': ariaDescribedBy,
            'aria-readonly': state.isReadOnly || !segment.isEditable ? 'true' : undefined,
            'data-placeholder': segment.isPlaceholder || undefined,
            contentEditable: isEditable,
            suppressContentEditableWarning: isEditable,
            spellCheck: isEditable ? 'false' : undefined,
            autoCapitalize: isEditable ? 'off' : undefined,
            autoCorrect: isEditable ? 'off' : undefined,
            // Capitalization was changed in React 17...
            [parseInt($cIPI0$react.version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,
            inputMode: state.isDisabled || segment.type === 'dayPeriod' || segment.type === 'era' || !isEditable ? undefined : 'numeric',
            tabIndex: state.isDisabled ? undefined : 0,
            onKeyDown: onKeyDown,
            onFocus: onFocus,
            style: {
                caretColor: 'transparent'
            },
            // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.
            onPointerDown (e) {
                e.stopPropagation();
            },
            onMouseDown (e) {
                e.stopPropagation();
            }
        })
    };
}
function $32489daedd52963e$var$commonPrefixLength(strings) {
    // Sort the strings, and compare the characters in the first and last to find the common prefix.
    strings.sort();
    let first = strings[0];
    let last = strings[strings.length - 1];
    for(let i = 0; i < first.length; i++){
        if (first[i] !== last[i]) return i;
    }
    return 0;
}











function $887cac91b7cc8801$export$12fd5f0e9f4bb192(props, state, ref) {
    var ref1, ref2;
    let formatMessage = $cIPI0$useMessageFormatter((/*@__PURE__*/$parcel$interopDefault($204383cf4f6b0d06$exports)));
    let { labelProps: labelProps , fieldProps: fieldProps , descriptionProps: descriptionProps , errorMessageProps: errorMessageProps  } = $cIPI0$useField({
        ...props,
        labelElementType: 'span'
    });
    let labelledBy = fieldProps['aria-labelledby'] || fieldProps.id;
    let { locale: locale  } = $cIPI0$useLocale();
    let range = state.formatValue(locale, {
        month: 'long'
    });
    let description = range ? formatMessage('selectedRangeDescription', {
        startDate: range.start,
        endDate: range.end
    }) : '';
    let descProps = $cIPI0$useDescription(description);
    let startFieldProps = {
        'aria-label': formatMessage('startDate'),
        'aria-labelledby': labelledBy
    };
    let endFieldProps = {
        'aria-label': formatMessage('endDate'),
        'aria-labelledby': labelledBy
    };
    let buttonId = $cIPI0$useId();
    let dialogId = $cIPI0$useId();
    let groupProps = $3dfb0f96be0d6a08$export$4a931266a3838b86(state, ref);
    let ariaDescribedBy = [
        descProps['aria-describedby'],
        fieldProps['aria-describedby']
    ].filter(Boolean).join(' ') || undefined;
    let focusManager = $cIPI0$useMemo(()=>$cIPI0$createFocusManager(ref, {
            // Exclude the button from the focus manager.
            accept: (element)=>element.id !== buttonId
        })
    , [
        ref,
        buttonId
    ]);
    let commonFieldProps = {
        [$16f0b7bb276bc17e$export$7b3062cd49e80452]: focusManager,
        [$16f0b7bb276bc17e$export$300019f83c56d282]: 'presentation',
        'aria-describedby': ariaDescribedBy,
        minValue: props.minValue,
        maxValue: props.maxValue,
        placeholderValue: props.placeholderValue,
        hideTimeZone: props.hideTimeZone,
        hourCycle: props.hourCycle,
        granularity: props.granularity,
        isDisabled: props.isDisabled,
        isReadOnly: props.isReadOnly,
        isRequired: props.isRequired,
        validationState: state.validationState
    };
    let domProps = $cIPI0$filterDOMProps(props);
    return {
        groupProps: $cIPI0$mergeProps(domProps, groupProps, fieldProps, descProps, {
            role: 'group',
            'aria-disabled': props.isDisabled || null,
            'aria-describedby': ariaDescribedBy
        }),
        labelProps: {
            ...labelProps,
            onClick: ()=>{
                focusManager.focusFirst();
            }
        },
        buttonProps: {
            ...descProps,
            id: buttonId,
            'aria-haspopup': 'dialog',
            'aria-label': formatMessage('calendar'),
            'aria-labelledby': `${labelledBy} ${buttonId}`,
            'aria-describedby': ariaDescribedBy,
            onPress: ()=>state.setOpen(true)
        },
        dialogProps: {
            id: dialogId,
            'aria-labelledby': `${labelledBy} ${buttonId}`
        },
        startFieldProps: {
            ...startFieldProps,
            ...commonFieldProps,
            value: (ref1 = state.value) === null || ref1 === void 0 ? void 0 : ref1.start,
            onChange: (start)=>state.setDateTime('start', start)
            ,
            autoFocus: props.autoFocus
        },
        endFieldProps: {
            ...endFieldProps,
            ...commonFieldProps,
            value: (ref2 = state.value) === null || ref2 === void 0 ? void 0 : ref2.end,
            onChange: (end)=>state.setDateTime('end', end)
        },
        descriptionProps: descriptionProps,
        errorMessageProps: errorMessageProps,
        calendarProps: {
            autoFocus: true,
            value: state.dateRange,
            onChange: state.setDateRange,
            minValue: props.minValue,
            maxValue: props.maxValue,
            isDisabled: props.isDisabled,
            isReadOnly: props.isReadOnly,
            isDateUnavailable: props.isDateUnavailable,
            allowsNonContiguousRanges: props.allowsNonContiguousRanges,
            defaultFocusedValue: state.dateRange ? undefined : props.placeholderValue,
            validationState: state.validationState,
            errorMessage: props.errorMessage
        }
    };
}





export {$6057a3d2a53a12fd$export$42df105a73306d51 as useDatePicker, $32489daedd52963e$export$1315d136e6f7581 as useDateSegment, $16f0b7bb276bc17e$export$5591b0b878c1a989 as useDateField, $16f0b7bb276bc17e$export$4c842f6a241dc825 as useTimeField, $887cac91b7cc8801$export$12fd5f0e9f4bb192 as useDateRangePicker, $3aeceb3a64eb8358$export$d42c60378c8168f8 as useDisplayNames};
//# sourceMappingURL=module.js.map
